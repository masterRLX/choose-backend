import express from 'express';
import axios from 'axios';
import cors from 'cors';

const app = express();
const PORT = 8080;
app.use(cors());
app.use(express.json());

const MET_API_BASE_URL = 'https://collectionapi.metmuseum.org/public/collection/v1';
const BATCH_SIZE = 5;
const cache = new Map();
// 404 Îì±ÏúºÎ°ú Ïã§Ìå®Ìïú objectIDÎ•º Í∏∞ÏñµÌïòÏó¨ Îã§Ïãú ÏöîÏ≤≠ÌïòÏßÄ ÏïäÎèÑÎ°ù ÌïòÎäî Set (ÏÉàÎ°úÏö¥ Í∏∞Îä•)
const failedObjectIDs = new Set(); 

// --- Rate Limit ÌöåÌîº Î∞è ÏïàÏ†ïÏÑ± Í∞ïÌôîÎ•º ÏúÑÌïú ÏÉÅÏàò ---
const API_REQUEST_DELAY_MS = 600; // API ÏöîÏ≤≠ Í∞Ñ ÏµúÏÜå ÎîúÎ†àÏù¥ (0.6Ï¥àÎ°ú ÏïΩÍ∞Ñ Ï¶ùÍ∞Ä)
const MAX_SEARCH_RETRIES = 3;     // Í≤ÄÏÉâ Ïã§Ìå® Ïãú ÏµúÎåÄ Ïû¨ÏãúÎèÑ ÌöüÏàò
const MAX_DETAIL_RETRIES = 5;     // ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ïã§Ìå® Ïãú ÏµúÎåÄ Ïû¨ÏãúÎèÑ ÌöüÏàò
const RETRY_DELAY_MULTIPLIER = 1000; // Ïû¨ÏãúÎèÑ ÎîúÎ†àÏù¥ Ï¶ùÍ∞ÄÎüâ (1Ï¥à * ÏãúÎèÑ ÌöüÏàò)


const shuffleArray = (array) => { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; };

// ÏÑúÎ≤ÑÎèÑ emojiPaintingMap Ï†ïÎ≥¥Í∞Ä ÌïÑÏöîÌïòÎØÄÎ°ú Ïó¨Í∏∞Ïóê ÏßÅÏ†ë Ï†ïÏùòÌï©ÎãàÎã§.
const emojiPaintingMap = {
    'üòå': { keywordGroups: [['portraits', 'landscapes', 'still life', 'serene']], title: 'Î™®ÎÇòÎ¶¨Ïûê - Î†àÏò§ÎÇòÎ•¥ÎèÑ Îã§ÎπàÏπò' },
    'ü§©': { keywordGroups: [['mythological', 'triumph', 'angels', 'cathedral', 'gold']], title: 'ÏïÑÎã¥Ïùò Ï∞ΩÏ°∞ - ÎØ∏ÏºàÎûÄÏ†§Î°ú' },
    'üòÇ': { keywordGroups: [['celebration', 'dance', 'children', 'festival', 'playful']], title: 'ÏßÑÏ£º Í∑ÄÍ≥†Î¶¨Î•º Ìïú ÏÜåÎÖÄ - ÏöîÌïòÎÑ§Ïä§ Î≤†Î•¥Î©îÎ•¥' },
    'üòä': { keywordGroups: [['portraits', 'smile', 'mother', 'child', 'flowers']], title: 'ÏûêÌôîÏÉÅ - ÎπàÏÑºÌä∏ Î∞ò Í≥†Ìùê' },
    'üòé': { keywordGroups: [['portraits', 'fashion', 'elegant', 'cityscape', 'modern art']], title: 'Í∑∏ÎûëÎìú ÏûêÌä∏ ÏÑ¨Ïùò ÏùºÏöîÏùº Ïò§ÌõÑ - Ï°∞Î•¥Ï£º Ïá†Îùº' },
    'üòÅ': { keywordGroups: [['music', 'dance', 'party', 'laughing', 'vibrant']], title: 'Î¨ºÎû≠ Îìú Îùº Í∞àÎ†àÌä∏Ïùò Î¨¥ÎèÑÌöå - ÌîºÏóêÎ•¥ Ïò§Í∑ÄÏä§Ìä∏ Î•¥ÎàÑÏïÑÎ•¥' },
    'ü•∞': { keywordGroups: [['love', 'couple', 'embrace', 'venus', 'mother and child']], title: 'ÌÇ§Ïä§ - Íµ¨Ïä§ÌÉÄÌîÑ ÌÅ¥Î¶ºÌä∏' },
    'ü•≥': { keywordGroups: [['celebration', 'party', 'triumph', 'wedding', 'festival']], title: 'ÎùºÏä§ Î©îÎãàÎÇòÏä§ - ÎîîÏóêÍ≥† Î≤®ÎùºÏä§ÏºÄÏä§' },
    'üò¥': { keywordGroups: [['night', 'landscapes', 'moon', 'dream', 'stillness']], title: 'Î≥ÑÏù¥ ÎπõÎÇòÎäî Î∞§ - ÎπàÏÑºÌä∏ Î∞ò Í≥†Ìùê' },
    'ü§Ø': { keywordGroups: [['abstract art', 'surrealism', 'cubism', 'geometry']], title: 'Ï†àÍ∑ú - ÏóêÎìúÎ∞îÎ•¥ Î≠âÌÅ¨' },
    'üò°': { keywordGroups: ['serene landscapes', 'still life with flowers', 'madonna and child', 'peace'], title: '1808ÎÖÑ 5Ïõî 3Ïùº - ÌîÑÎûÄÏãúÏä§ÏΩî Í≥†Ïïº' },
    'ü•∂': { keywordGroups: ['warmth', 'comfort', 'light', 'fire', 'sun', 'summer'], title: 'ÏïàÍ∞ú Î∞îÎã§ ÏúÑÏùò Î∞©ÎûëÏûê - Ïπ¥Ïä§ÌååÎ•¥ Îã§ÎπÑÌä∏ ÌîÑÎ¶¨ÎìúÎ¶¨Ìûà' },
    'ü•∫': { keywordGroups: ['hope', 'light', 'angels', 'saints', 'charity', 'sunrise'], title: 'ÎπÑÎÑàÏä§Ïùò ÌÉÑÏÉù - ÏÇ∞ÎìúÎ°ú Î≥¥Ìã∞Ï≤ºÎ¶¨' },
    'ü§î': { keywordGroups: ['sculpture', 'philosophy', 'manuscripts', 'maps', 'self-portraits'], title: 'ÏÉùÍ∞ÅÌïòÎäî ÏÇ¨Îûå - Ïò§Í∑ÄÏä§Ìä∏ Î°úÎåï' },
    'ü§´': { keywordGroups: ['interiors', 'letters', 'window', 'symbols', 'allegory', 'secret'], title: 'ÏïÑÎ©îÎ¶¨Ïπ∏ Í≥†Îîï - Í∑∏ÎûúÌä∏ Ïö∞Îìú' },
    'üò≠': { keywordGroups: ['hope', 'light', 'landscapes', 'sunrise', 'solace', 'healing'], title: 'ÏµúÌõÑÏùò ÎßåÏ∞¨ - Î†àÏò§ÎÇòÎ•¥ÎèÑ Îã§ÎπàÏπò' }
};

const fetchPaintingsInBackground = async (emoji) => {
    const emojiCache = cache.get(emoji);
    if (!emojiCache || emojiCache.isFetching) return;
    emojiCache.isFetching = true;
    cache.set(emoji, emojiCache);

    try {
        let newFoundPaintings = [];
        let currentIndex = emojiCache.processedIndex;
        
        const targetFetchCount = BATCH_SIZE * 5; 
        
        while (newFoundPaintings.length < targetFetchCount && currentIndex < emojiCache.objectIDs.length) {
            const objectID = emojiCache.objectIDs[currentIndex++];
            // Ïù¥ÎØ∏ Ïã§Ìå®Ìïú IDÎäî Í±¥ÎÑàÎúÅÎãàÎã§.
            if (!objectID || failedObjectIDs.has(objectID)) { 
                // console.log(`Skipping failed or invalid objectID: ${objectID}`); // ÎîîÎ≤ÑÍπÖÏö©
                continue; 
            }

            for (let i = 0; i < MAX_DETAIL_RETRIES; i++) {
                try {
                    await new Promise(resolve => setTimeout(resolve, API_REQUEST_DELAY_MS));
                    const detailUrl = `${MET_API_BASE_URL}/objects/${objectID}`;
                    const detailResponse = await axios.get(detailUrl, { timeout: 7000 });

                    if (detailResponse.data && (detailResponse.data.primaryImage || detailResponse.data.primaryImageSmall)) {
                        newFoundPaintings.push({
                            img_lq: detailResponse.data.primaryImageSmall,
                            img_hq: detailResponse.data.primaryImage || detailResponse.data.primaryImageSmall,
                            title: detailResponse.data.title || 'Ï†úÎ™© ÏóÜÏùå',
                            artist: detailResponse.data.artistDisplayName || 'ÏûëÍ∞Ä ÎØ∏ÏÉÅ',
                            objectURL: detailResponse.data.objectURL || '#'
                        });
                        break;
                    } else {
                        // Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞ÎèÑ Ïã§Ìå®Î°ú Í∞ÑÏ£ºÌïòÍ≥† failedObjectIDsÏóê Ï∂îÍ∞Ä
                        console.warn(`[BG Detail Skip] Object ID ${objectID}: No primary image.`);
                        failedObjectIDs.add(objectID);
                        break; // Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏóÜÏúºÎ©¥ Ïû¨ÏãúÎèÑÌï¥ÎèÑ ÏÜåÏö©ÏóÜÏúºÎãà ÌÉàÏ∂ú
                    }
                } catch (e) {
                    const status = e.response ? e.response.status : 'N/A';
                    console.warn(`[BG Detail Error] Object ID ${objectID} (Attempt ${i + 1}/${MAX_DETAIL_RETRIES}, Status: ${status}): ${e.message}`);
                    if (status === 403 || status === 404 || i === MAX_DETAIL_RETRIES - 1) {
                         // 403, 404Îäî Ïû¨ÏãúÎèÑ Î¨¥ÏùòÎØ∏, ÎòêÎäî ÎßàÏßÄÎßâ ÏãúÎèÑ Ïã§Ìå® Ïãú
                         console.error(`[BG Detail Error] Aborting retries for ${objectID} due to status ${status} or max retries.`);
                         failedObjectIDs.add(objectID); // Ïã§Ìå®Ìïú ID Í∏∞Î°ù
                         break;
                    }
                    await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MULTIPLIER * (i + 1)));
                }
            }
        }
        if (newFoundPaintings.length > 0) {
            emojiCache.paintings.push(...shuffleArray(newFoundPaintings));
        }
        emojiCache.processedIndex = currentIndex;
    } catch (error) {
        console.error(`[BG Fetch Error] For ${emoji}:`, error.message);
    }
    finally {
        emojiCache.isFetching = false;
        cache.set(emoji, emojiCache);
    }
};

app.get('/api/painting', async (req, res) => {
    const { emoji } = req.query;
    if (!emoji) return res.status(400).json({ error: 'Emoji is required' });

    if (cache.has(emoji)) {
        const emojiCache = cache.get(emoji);
        if (emojiCache.paintings.length > 0) {
            const batchToSend = emojiCache.paintings.splice(0, BATCH_SIZE);
            res.json(batchToSend);
            fetchPaintingsInBackground(emoji);
            return;
        }
        if (!emojiCache.isFetching) { 
            console.log(`[Cache Miss] Starting background fetch for ${emoji}`);
            await fetchPaintingsInBackground(emoji);
            const updatedCache = cache.get(emoji);
            if (updatedCache.paintings.length > 0) {
                const batchToSend = updatedCache.paintings.splice(0, BATCH_SIZE);
                res.json(batchToSend);
                fetchPaintingsInBackground(emoji);
                return;
            }
        }
        if (emojiCache.processedIndex >= emojiCache.objectIDs.length && emojiCache.paintings.length === 0) {
            return res.status(404).json({ error: 'All available paintings for this emoji have been shown.' });
        } else {
            return res.status(202).json({ message: 'Fetching more paintings in the background. Please try again shortly.' });
        }
    }

    try {
        const paintingData = emojiPaintingMap[emoji];
        if (!paintingData) {
            console.error(`Invalid emoji: ${emoji}`);
            return res.status(400).json({ error: 'Invalid emoji provided.' });
        }

        let allObjectIDs = [];
        const searchKeywordStrings = paintingData.keywordGroups.map(group => group.join(','));
        
        for (const keywordString of searchKeywordStrings) {
            let searchUrl = `${MET_API_BASE_URL}/search?q=${encodeURIComponent(keywordString)}&hasImages=true`;

            for (let i = 0; i < MAX_SEARCH_RETRIES; i++) {
                try {
                    await new Promise(resolve => setTimeout(resolve, API_REQUEST_DELAY_MS));
                    const searchResponse = await axios.get(searchUrl, { timeout: 15000 });
                    if (searchResponse.data && Array.isArray(searchResponse.data.objectIDs)) {
                        allObjectIDs.push(...searchResponse.data.objectIDs);
                        break;
                    }
                } catch (searchError) {
                    const status = searchError.response ? searchError.response.status : 'N/A';
                    console.warn(`[Search Error] Keyword group [${keywordString}] (Attempt ${i + 1}/${MAX_SEARCH_RETRIES}, Status: ${status}): ${searchError.message}`);
                    if (status === 403 || i === MAX_SEARCH_RETRIES - 1) { // 403ÏùÄ Ïû¨ÏãúÎèÑ Î¨¥ÏùòÎØ∏, ÎßàÏßÄÎßâ ÏãúÎèÑ Ïã§Ìå® Ïãú
                        console.error(`[Search Error] Aborting retries for search due to status ${status} or max retries.`);
                        break;
                    }
                    await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MULTIPLIER * (i + 1)));
                }
            }
        }

        if (allObjectIDs.length === 0) {
            return res.status(404).json({ error: `No objects found for the emoji keywords: ${emoji}` });
        }

        // Ï§ëÎ≥µ Ï†úÍ±∞ Î∞è failedObjectIDsÏóê ÏûàÎäî ID Ï†úÍ±∞ ÌõÑ ÏÖîÌîå
        const uniqueShuffledObjectIDs = shuffleArray([...new Set(allObjectIDs)].filter(id => !failedObjectIDs.has(id)));

        const newCacheEntry = { paintings: [], objectIDs: uniqueShuffledObjectIDs, processedIndex: 0, isFetching: false };
        cache.set(emoji, newCacheEntry);

        await fetchPaintingsInBackground(emoji);

        const finalCache = cache.get(emoji);
        if (finalCache.paintings.length > 0) {
            const batchToSend = finalCache.paintings.splice(0, BATCH_SIZE);
            res.json(batchToSend);
            fetchPaintingsInBackground(emoji);
        } else {
            res.status(404).json({ error: 'Could not find any valid paintings from the initial search.' });
        }
    } catch (error) {
        console.error(`[FATAL SERVER ERROR] For ${emoji}:`, error.message);
        return res.status(500).json({ error: 'Failed to process request for painting data.' });
    }
});

app.listen(PORT, () => {
    console.log(`ÏµúÏ¢Ö ÏôÑÏÑ± ÏÑúÎ≤ÑÍ∞Ä http://localhost:${PORT} Ìè¨Ìä∏ÏóêÏÑú Ïã§Ìñâ Ï§ëÏûÖÎãàÎã§.`);
});